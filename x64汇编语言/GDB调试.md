---
title: GDB调试
description: 学习gdb的基本使用，修改hello程序
published: true
date: 2022-07-29T15:17:20.812Z
tags: 汇编语言, x64
editor: markdown
dateCreated: 2022-07-29T14:57:33.367Z
---

# GDB
gdb是一个调试器，通过它可以逐步指令的同时，查看内存、寄存器和标志的变化。它是一个命令行程序，要想使用它就得熟悉其基本的指令。

## 调试hello
使用指令`gdb hello`调试之前写的hello程序，输入指令`list`，即可显示多行代码，再次输入则会显示后面的几行，如下图所示。
![x64汇编语言_gdb_1.jpg](/x64汇编语言_gdb_1.jpg){.align-center}
再输入指令`disassemble main`，则可以看到main标签下的反汇编代码，但是gcc默认配置的是`AT&T`语法，我们将使用更为熟悉的`intel`语法。所以使用指令`set disassembly-flavor intel`修改语法，或者在用户目录下（主目录）创建文件`.gdbinit`文件，将之前的set指令写进去，保存退出后，重新登录用户，再次使用gdb语法就更改成功了，如下图所示。
![x64汇编语言_gdb_2.jpg](/x64汇编语言_gdb_2.jpg){.align-center}
在上图中，最左侧一列是程序的指令所存储的内存地址，再右边一列是对应起始地址的偏移，最右边一列就是程序的反汇编代码。
在`hello.asm`中我们将`0x1`这个数传入的寄存器是`rax`，但是在上图中却变成了`eax`。其实通过上篇我们知道，`eax`就是`rax`的第32位寄存器。**汇编器觉得用64位寄存器存储一个1位的数字`0x1`有点杀鸡用牛刀的感觉，所以就只使用了低32位寄存器，像上图中的`edi`和`edx`道理也是一样**。

我们还可以发现，原来`hello.asm`中的`mov rsi msg`在gdb反汇编中变成了`movabs rsi 0x404028`。目前`movabs`我们不必深究它，就把它当作一个`mov`指令。这条指令的意思是吧`0x404028`这个地址上的值传入寄存器`rsi`。我们可以在gdb中使用指令`x/s 0x404028`查看一下这个地址（其中x表示查询，s表示以字符串形式显示），如下图所示：
![x64汇编语言_gdb_3.jpg](/x64汇编语言_gdb_3.jpg){.align-center}

**还有许多其它的查询方式，例如**：
- `x/c 0x404028` 以字符形式查询
- `x/13c 0x404028` 查询从目标地址开始的13个字符
- `x/13d 0x404028` 从目标地址开始以十进制形式查询13个字符（ascii码）
- ‘x/13x 0x404028’ 从目标地址开始以十六进制形式查询13个字符（ascii码）
- ‘x/s &msg’ 以字符形式查询msg该变量地址上的值

**演示如下图所示**：
![x64汇编语言_gdb_4.jpg](/x64汇编语言_gdb_4.jpg){.align-center}



# hello2

