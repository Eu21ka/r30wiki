---
title: 第一个程序
description: 编写第一个汇编程序以及汇编程序的结构分析
published: true
date: 2022-07-26T10:15:05.079Z
tags: 汇编语言, x64
editor: markdown
dateCreated: 2022-07-26T03:53:33.797Z
---

# Hello World
学过编程的小伙伴大部分学某个新的语法的时候，编写的第一个程序应该都是`Hello World`吧，不得不说它真的是太经典了。接下来我们要编写的程序当然也是它，一开始不用太关注程序本身，跟着操作就行。

## hello.asm
在虚拟机上创建一个名为`hello.asm`的文件，其中`.asm`就是汇编文件的后缀，下面是`Hello World`这个程序的源码。
```asm
section .data
  msg db "hello, world",0		;表示可读字符串的结尾，不算入字符串长度
section .bss
section .text
  global main
main:
  mov	rax, 1			;1表示写入
  mov	rdi, 1			;1标准输出
  mov	rsi, msg		;msg作为参数传入rsi
  mov	rdx, 12     ;表示输出的字符串长度
  syscall					;系统调用
  mov	rax, 60     ;60表示退出
  mov	rdi, 0			;0是成功退出代码
  syscall					;退出
```
上诉代码中，我们用换行符来使代码更有层次，便于阅读，其中`;`后的内容在代码中表示注释。

## makefile
makefile文件顾名思义它就是用来“make file”的（疑是废话文学），它是用来自动化编译c/c++也可以用来自动化编译汇编，写好makefile文件后，只需`make`指令即可自动编译，就像一个专门用来编译的shell脚本。
```
#makefile for hello.asm
hello: hello.o
	gcc -o hello hello.o -no-pie
hello.o: hello.asm
	nasm -f elf64 -g -F dwarf hello.asm -l hello.lst
```
为了更好理解上诉代码的作用，我们可以从后往前阅读。其中`hello.o`依赖于`hello.asm`，`hello`依赖于`hello.o`。`makefile`中的第一个依赖关系称为第一规则，此规则的第一个目标称为“最终目标”，也就是我们最终要生成的文件。`makefile`在被执行的时候，它就会现比较`hello.o`和`hello.asm`的创建时间，如果`hello.asm`的最后修改时间比`hello.o`晚（更“新”），那么就会执行该依赖关系下的指令，重新进行编译。反之则跳过该过程，直接比较上一条依赖关系。

现在来解释一下最后一句话，`nasm`为被用来的汇编器。`-f`后面跟着的是输出格式，`elf64`指的是生成64位可执行和可链接格式。`-g`指以`-F`后面的调试格式包含调试信息，`dwarf`为一种调试格式，是“Debug With Arbitrary Record Format”缩写。`-l`表示生成`.list`文件，最后结束后NASM还会生成一个`.o`结尾的目标文件。该目标文件还不能直接被执行，还需要被gcc链接后生成可执行的二进制文件，也就是`makefile`中的第三行的作用。其中`-o`表示定义生成的二进制文件名为`hello`，如果不指定文件名则默认生成的文件名为`a.out`。`-no-pie`指的是关闭地址随机，有pwn基础的小伙伴应该很熟悉。

写好`makefile`后并执行指令`make`后，就会出现`hello`文件，使用指令`./hello`运行，就会在看到"hello world"被输出了出来。

# 汇编程序的结构
从`hello.asm`中我们就可以发现，一个汇编程序由`.data`、`.bss`、`.text`这三个段组成。

## .data段
用来定义已初始化的变量，**当目标文件被链接的时候，就会为该定义好的变量分配内存**，定义格式如下：
`<变量名称>	<类型> <值>`

变量名以字母开头，后面可跟在字母、数字或特殊字符，类型如下表：
| 类型 |    长度     |        名称         |
| :--: | :---------: | :-----------------: |
|  db  | 8bit（位）  |    Byte（字节）     |
|  dw  | 16bit（位） |     Word（字）      |
|  dd  | 32bit（位） | Double word（双字） |
|  dq  | 64bit（位） |  Quad word（四字）  |

在汇编代码中，变量名指的就是该变量在内存中的首地址。因此在`hello.asm`中，`msg`指向的就是字符`h`的地址，`msg+1`指向的也就是字母`e`的地址。所以字符串在内存中其实就是由连续内存的字符组成而来的，类似的数组中的每个元素在内存中也是连续 的。

`.data`段中还可以定义常量，声明格式如下：
`<常量名>	<equ>	<值>`
例如：**pi	equ	123**

## .bss段
用来声明未初始化的变量，声明格式如下：
`<变量名>	<类型>	<数字>`

数据类型如下表：
| 类型 |    长度     |        名称         |
| :--: | :---------: | :-----------------: |
| resb | 8bit（位）  |    Byte（字节）     |
| resw | 16bit（位） |     Word（字）      |
| resd | 32bit（位） | Double word（双字） |
| resq | 64bit（位） |  Quad word（四字）  |

**`.bss`段声明的变量在程序开始执行的时候才开始分配内存的，这时变量被初始化为零，如果没有足够的内存分配给这些变量的化，程序将会崩溃。**

## .txt段
该段用来保存程序的操作指令，`global`声明了程序的入口，`main:`是一个标签，后面跟着是这个标签下要执行的操作代码。所以开头的`global main`定义了程序从main标签下的代码开始执行。

`mov`指令可以理解为`赋值`操作，用法如下：
- mov 寄存器, 值
- mov 寄存器, 内存
- mov 内存, 寄存器
- **不合法：mov 内存, 内存**

**值得注意的是，我们利用mov赋值后，“取值来源地”的值是不变的，这相当于一个复制的过程。**

## hello.lst
在`makefile`中我们要求汇编后生成`hello.lst`，现在我们来看看里面的内容。
![hello.lst.jpg](/hello.lst.jpg)

第一列是代码的相对地址，第二列是代码的十六进制机器码。其中`mov rax`的机器码为`B8`，`mov rdi`的机器码为`BF`。其中“68656C6C6F2C20776F726C64”就是“hello, world”的16进制ascii码。执行的第一调指令从`00000000`开始，占5个字节（B8 01 00 00 00）,最后两个双零（00）用来内存对齐，目的是优化代码的功能。下条指令从`00000005`开始。可见内存地址是个8位的数字（即8个字节），因为1byte（字节）= 8bit（位）,所以程序是64位寻址。正好对应我们用的64位汇编器。`[0000000000000000]`用来标记`msg`，因位还不知道它的存储位置，