---
title: 第一个程序
description: 编写第一个汇编程序以及汇编程序的结构分析
published: true
date: 2022-07-26T08:11:11.387Z
tags: 汇编语言, x64
editor: markdown
dateCreated: 2022-07-26T03:53:33.797Z
---

# Hello World
学过编程的小伙伴大部分学某个新的语法的时候，编写的第一个程序应该都是`Hello World`吧，不得不说它真的是太经典了。接下来我们要编写的程序当然也是它，一开始不用太关注程序本身，跟着操作就行。

## hello.asm
在虚拟机上创建一个名为`hello.asm`的文件，其中`.asm`就是汇编文件的后缀，下面是`Hello World`这个程序的源码。
```asm
section .data
  msg db "hello, world",0
section .bss
section .text
  global main
main:
  mov	rax, 1			;1表示写入
  mov	rdi, 1			;1标准输出
  mov	rsi, msg		;msg作为参数传入rsi
  mov	rdx, 12     ;表示输出的字符串长度
  syscall					;系统调用
  mov	rax, 60     ;60表示退出
  mov	rdi, 0			;0是成功退出代码
  syscall					;退出
```
上诉代码中，我们用换行符来使代码更有层次，便于阅读，其中`;`后的内容在代码中表示注释。

## makefile
makefile文件顾名思义它就是用来“make file”的（疑是废话文学），它是用来自动化编译c/c++也可以用来自动化编译汇编，写好makefile文件后，只需`make`指令即可自动编译，就像一个专门用来编译的shell脚本。
```
#makefile for hello.asm
hello: hello.o
	gcc -o hello hello.o -no-pie
hello.o: hello.asm
	nasm -f elf64 -g -F dwarf hello.asm -l hello.lst
```
为了更好理解上诉代码的作用，我们可以从后往前阅读。其中`hello.o`依赖于`hello.asm`，`hello`依赖于`hello.o`。`makefile`中的第一个依赖关系称为第一规则，此规则的第一个目标称为“最终目标”，也就是我们最终要生成的文件。`makefile`在被执行的时候，它就会现比较`hello.o`和`hello.asm`的创建时间，如果`hello.asm`的最后修改时间比`hello.o`晚（更“新”），那么就会执行该依赖关系下的指令，重新进行编译。反之则跳过该过程，直接比较上一条依赖关系。

现在来解释一下最后一句话，`nasm`为被用来的汇编器。`-f`后面跟着的是输出格式，`elf64`指的是生成64位可执行和可链接格式。`-g`指以`-F`后面的调试格式包含调试信息，`dwarf`为一种调试格式，是“Debug With Arbitrary Record Format”缩写。`-l`表示生成`.list`文件，最后结束后NASM还会生成一个`.o`结尾的目标文件。该目标文件还不能直接被执行，还需要被gcc链接后生成可执行的二进制文件，也就是`makefile`中的第三行的作用。其中`-o`表示定义生成的二进制文件名为`hello`，如果不指定文件名则默认生成的文件名为`a.out`。`-no-pie`指的是关闭地址随机，有pwn基础的小伙伴应该很熟悉。

写好`makefile`后并执行指令`make`后，就会出现`hello`文件，使用指令`./hello`运行，就会在看到"hello world"被输出了出来。


